МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторінг коду»
на тему «Методи рефакторингу коду: Rename Method, Hide Method, Form Template Method»









Виконав:                                                           	     Перевірив:
ст. гр. ПЗПІ-23-10                                                       Старший викл. Кафедри ПІ
Шахмаєв Д.О                                                              Сокорчук І.П.



Харків 2025
1. ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень109.11.250.1Зроблена презентація та документ210.11.250.2Зроблені розділи 1,2,3,4,5, Додатки А, В




























2. ЗАВДАННЯ
     Метою даної практичної роботи є детальний аналіз та практичне застосування трьох методів рефакторингу програмного коду. Відповідно до завдання, необхідно було обрати три унікальних методи рефакторингу з книги Мартіна Фаулера "Refactoring: Improving the Design of Existing Code".
     Для цієї роботи були обрані наступні методи:
➢ Rename Method стор. 179;
➢ Hide Method стор. 199;
➢ Form Template Method стор. 226.
     Ключовим аспектом завдання є демонстрація застосування цих методів на прикладах особистого коду (з курсових або лабораторних робіт), порівнюючи стан коду "до" та "після" рефакторингу.
     















3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1. Вступ до рефакторингу
     Тема моєї доповіді - практичне застосування методів рефакторингу для покращення якості програмного забезпечення. Ця тема є надзвичайно актуальною, оскільки рефакторинг є невід'ємною частиною сучасного процесу розробки.
     Рефакторинг - це процес покращення внутрішньої структури існуючого коду без зміни його зовнішньої поведінки. Як було детально розглянуто у моїй першій практичній роботі, дотримання принципів "чистого коду" та філософії "The Go Way" є фундаментом для створення якісного, високопродуктивного та підтримуваного коду. Рефакторинг є саме тим інструментом, який дозволяє підтримувати цей стандарт якості протягом усього життя проєкту.
     Основна мета рефакторингу - зробити код більш зрозумілим, легшим для майбутніх модифікацій та менш схильним до помилок. Це не одноразова дія, а постійний процес вдосконалення, який запобігає "занепаду" проекту, коли код стає занадто складним для підтримки. Таким чином, рефакторинг є важливою інвестицією у майбутнє проекту, яка окупається зменшенням витрат на подальшу розробку та підтримку.
3.2  Огляд обраних методів
   Для виконання практичної роботи було обрано три specific методи рефакторингу, кожен з яких вирішує поширені проблеми у вихідному коді та покращує його архітектуру, спираючись на принципи чистого коду: 
     Rename Method (Перейменування методу): Це фундаментальний метод, спрямований на покращення читабельності . Він полягає у зміні назви методу (функції) на таку, що чітко та ясно описує його призначення.
     Hide Method (Приховування методу): Цей метод покращує інкапсуляцію, що є ключовим для "The Go Way" . Якщо метод використовується лише всередині свого класу (або пакета в Go) і не призначений для зовнішнього використання, його слід зробити приватним. 
     Form Template Method (Формування шаблонного методу): Цей метод усуває дублювання коду (принцип DRY) . Він використовується, коли кілька алгоритмів мають однакову структуру (скелет), але відрізняються в деталях реалізації окремих кроків.
     Застосування цих методів допомагає покращити загальну архітектуру коду, роблячи його більш гнучким до змін, простішим для розуміння та менш схильним до помилок.
     3.3 Метод Rename Method
Проблема: Метод має незрозумілу, неповну або неінформативну назву (наприклад, proc, calc, handle). Це безпосередньо порушує один з ключових принципів чистого коду - читабельність, про важливість якої йшлося у першій роботі . Інший розробник (або навіть автор коду через деякий час) не може зрозуміти призначення функції, не прочитавши її повну реалізацію, що ускладнює підтримку та розвиток коду.
Рішення: Методу надається нова назва, яка чітко, повно та недвозначно описує, що він робить або який результат повертає. У мові Go це також стосується іменування аргументів та змінних, де назва має відображати суть даних.
Переваги:
• Підвищення читабельності: Код стає самодокументованим.
• Спрощення підтримки: Значно легше зрозуміти логіку програми та вносити зміни.
• Полегшення пошуку: Легше знайти потрібну функцію за її логічною назвою.
Недоліки:
• У мовах без потужних інструментів рефакторингу (IDE) цей процес може бути складним, оскільки вимагає ручного пошуку та заміни всіх викликів методу.
• Для публічних методів, які є частиною API, зміна назви є руйнівною зміною (breaking change) для користувачів цього API.
Практичне застосування: У вихідному коді (Див. Додаток В) функція мала неінформативну назву proc та аргумент d. Це ускладнювало розуміння її призначення. Під час рефакторингу (Див. Додаток В) функції було надано чітку назву ValidateUserCredentials, а аргументу — userData. Це миттєво пояснює, що функція займається валідацією даних користувача. Також було виправлено стиль тексту помилки згідно з рекомендаціями Go-лінтера.
3.4  Метод Hide Method
Проблема: Допоміжний метод, який є лише деталлю внутрішньої реалізації, є публічним. Це порушує фундаментальний принцип інкапсуляції. Інші частини програми (інші пакети) можуть почати залежати від цього методу, який не був для них призначений. Це ускладнює майбутні зміни та підтримку, оскільки розробник не може безпечно модифікувати чи видалити цей метод, не ризикуючи зламати інший код.
Рішення: Метод робиться приватним, щоб до нього можна було звертатися лише зсередини його власного класу чи пакета. У мові Go цей принцип реалізований особливо елегантно та суворо: для того, щоб зробити функцію чи метод приватним (неекспортованим), достатньо почати її назву з малої літери . Якщо назва починається з великої літери, вона експортується (публічна).
Переваги:
• Покращення інкапсуляції: Чітко розділяє публічний API пакета та його внутрішню "кухню".
• Зменшення зв'язаності (coupling): Інші пакети не можуть "зачепитися" за деталі реалізації, що дає свободу для рефакторингу.
• Підвищення гнучкості: Внутрішній приватний метод можна безпечно змінювати, оптимізувати або навіть видаляти, не побоюючись зламати зовнішній код.
Недоліки:
• Може ускладнити юніт-тестування, якщо приватний метод містить складну логіку, яку хотілося б протестувати ізольовано (хоча це часто є ознакою того, що клас/пакет робить занадто багато).
Практичне застосування: У коді "до" (Див. Додаток В) метод GetDBConnection був публічним (починався з великої літери G). Однак він був потрібен лише методу CreateReport всередині того ж пакета reports і був деталлю реалізації. Під час рефакторингу (Див. Додаток В) метод було перейменовано на getDBConnection (з малої літери g). Це автоматично зробило його приватним для пакета, приховавши деталь реалізації та зміцнивши інкапсуляцію, як того вимагає "The Go Way" .
     3.5 Метод Form Template Method
Проблема: Два або більше класів (або структур у Go) містять методи зі схожою послідовністю дій, тобто однаковим "скелетом" алгоритму, але ці дії відрізняються в деталях. Це призводить до значного дублювання коду, що є прямим порушенням принципу DRY (Don't Repeat Yourself) . Підтримка такого коду ускладнюється, оскільки будь-яка зміна в загальному алгоритмі вимагає внесення однакових правок у всі класи-дублікати.
Рішення: Створюється "шаблонний метод", який визначає загальний скелет алгоритму в одному місці. Кроки, що відрізняються, делегуються. В ідіоматичному Go, де відсутнє класичне спадкування, це рішення реалізується через інтерфейси та композицію.
1. Створюється інтерфейс, який описує набір методів, що являють собою кроки, які відрізняються.
2. Створюється єдина функція-"шаблон", яка приймає цей інтерфейс і викликає його методи у правильному, визначеному порядку.
3. Конкретні структури реалізують цей інтерфейс, надаючи унікальну логіку для кожного кроку.
Переваги:
• Усунення дублювання: Загальний алгоритм описаний лише в одному місці (у функції-"шаблоні").
• Гнучкість (Розширюваність): Дуже легко додавати нові варіації алгоритму. Достатньо створити нову структуру та реалізувати необхідний інтерфейс, не чіпаючи існуючий код.
• Дотримання принципу "The Go Way": Віддає перевагу композиції над спадкуванням.
Недоліки:
• Ускладнення: Призводить до збільшення кількості сутностей (інтерфейси, нові структури), що може бути надлишковим для дуже простих випадків .
• У Go цей патерн менш очевидний для початківців, оскільки вимагає чіткого розуміння роботи інтерфейсів.
Практичне застосування: У коді "до" (Див. Додаток В) структури TextReport та CsvReport мали методи Generate з абсолютно ідентичною послідовністю з трьох кроків, що призводило до прямого дублювання коду. Під час рефакторингу (Див. Додаток В) було створено інтерфейс reportImplementation (який описує кроки, що відрізняються: getData, formatData, saveFile) та єдину шаблонну функцію GenerateReport. Ця функція приймає інтерфейс і викликає його методи. Це дозволило повністю усунути дублювання та зробити систему гнучкою для додавання нових типів звітів у майбутньому.
     3.6 Результати рефакторингу
     Застосування трьох обраних методів рефакторингу мало комплексний позитивний вплив на якість коду, його архітектуру та подальшу підтримку. Кожен метод вирішив конкретні "запахи коду" (code smells), що в сумі призвело до значного покращення проекту.
1. Метод Rename Method (Розділ 2.3) безпосередньо покращив читабельність та зрозумілість коду, зробивши його самодокументованим, що є однією з головних вимог "The Go Way" .
2. Метод Hide Method (Розділ 2.4) посилив інкапсуляцію, чітко розділивши публічний API пакета від його внутрішньої реалізації. Це відповідає принципам Go, де видимість контролюється регістром літер .
3. Метод Form Template Method (Розділ 2.5), реалізований через інтерфейси, повністю усунув дублювання коду, дотримуючись принципу DRY (Don't Repeat Yourself) , та підвищив гнучкість архітектури для майбутніх розширень.
     Загалом, проведені зміни призвели до того, що код стало легше підтримувати та додавати новий функціонал з меншою ймовірністю виникнення помилок. Дотримання цих принципів покращило тестованість компонентів та привело код у відповідність до стандартів професійної розробки на Go.
     3.7 Інструменти рефакторингу
Хоча рефакторинг, описаний у попередніх розділах, можна виконувати вручну, сучасні інструменти для мови Go роблять цей процес значно безпечнішим та ефективнішим .
Основою для розробника на Go є потужний вбудований набір інструментів, частина з яких була розглянута у першій практичній роботі:
• go fmt: Цей інструмент автоматично форматує код за єдиним стандартом. Це хоч і не рефакторинг логіки, але є першим і обов'язковим кроком до "чистого коду".
• go vet: Статичний аналізатор, який допомагає знаходити підозрілі конструкції та потенційні логічні помилки, які компілятор вважає синтаксично правильними .
Окрім них, ключову роль відіграють:
• Сучасні Лінтери (напр. go-staticcheck): Як показав практичний досвід під час виконання цієї роботи, інструменти на кшталт go-staticcheck є незамінними. Вони аналізують код "на льоту" і вказують на проблеми, такі як "невикористаний код" (помилка U1000) або порушення стилю (error strings should not be capitalized - помилка ST1005), що спонукає до негайного виправлення та рефакторингу.
• Системи контролю версій (Git): Git є "страхувальною сіткою" для розробника. Він дозволяє безпечно експериментугувати зі значними змінами у коді, створювати окремі гілки для рефакторингу та миттєво відкочувати будь-які невдалі спроби.
Поєднання цих інструментів перетворює рефакторинг на керований, безпечний та високоефективний процес, що дозволяє постійно покращувати код без ризику пошкодити існуючу функціональність.













4. ВИСНОВКИ
Під час виконання даної практичної роботи було детально проаналізовано та застосовано на практиці три фундаментальні методи рефакторингу: Rename Method, Hide Method та Form Template Method.
Виконана робота практично підтвердила, що рефакторинг є критично важливою та невід'ємною складовою сучасної розробки програмного забезпечення. Це не одноразова дія, а безперервний процес, який дозволяє підтримувати "здоров'я", гнучкість та ефективність кодової бази протягом усього її життєвого циклу.
Застосування обраних методів на прикладах мови Go чітко продемонструвало, як ідіоми мови впливають на реалізацію патернів. Ми побачили, як:
• Rename Method безпосередньо покращує читабельність, що є ключовим для "The Go Way" .
• Hide Method посилює інкапсуляцію через вбудований у мову механізм експорту (велика/мала літера) .
• Form Template Method усуває дублювання коду (DRY) шляхом ідіоматичного використання інтерфейсів замість класичного спадкування.
У підсумку, ця робота доводить, що рефакторинг — це не просто "прибирання коду" чи косметичне покращення. Це стратегічна інвестиція у майбутнє проекту. Вона безпосередньо зменшує накопичений технічний борг, що, у свою чергу, покращує продуктивність команди та забезпечує стабільність системи при неминучих подальших змінах вимог. Таким чином, код стає більш легким для підтримки, модифікації та розширення.




5. СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ
1. Офіційна Документація: https://golang.org/doc/
2. Фаулер, М. Рефакторинг: Поліпшення проектування існуючого коду.
3. Refactoring.guru. (2025). Каталог методів рефакторингу. https://refactoring.guru/uk/catalog




















ДОДАТОК А
Посилання відео на Youtube
Відеозапис доповіді: https://youtu.be/ao60cVUqQTw
Хронологічний опис відеозапису:
0:00 - Вступ
0:12 - Вступ до рефакторингу
1:53 - Пояснення першего методу (Rename method)
2:21 - Застосування першего методу (Rename method)
3:25 - Пояснення другого методу (Hide method)
4:18 - Застосування другого методу (Hide method)
4:36 - Пояснення третього методу (Form Template Method)
5:30 - Застосування третього методу частина 1 (Form Template Method)
6:17 - Застосування третього методу частина 2 (Form Template Method)
7:01 - Висновки
7:53 - Список джерел










ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний слайд 
Рисунок Б.2 – Важливість рефакторингу


Рисунок Б.3 – Пояснення методу “Rename method”

Рисунок Б.4 – Пояснення методу “Rename method”

Рисунок Б.5 – Пояснення методу “Hide method”

Рисунок Б.6 – Пояснення методу “ Hide method”

Рисунок Б.7 – Пояснення методу “ Form Template Method”

Рисунок Б.8 – Пояснення методу “ Form Template Method”

Рисунок Б.9 – Пояснення методу “ Form Template Method”
	
Рисунок Б.10 – Висновки рефакторингу

Рисунок Б.11 – Використані джерела

Рисунок Б.12 – Дякуємо за увагу






ДОДАТОК В
Програмний код
В.1 Метод "Replace Type Code with State/Strategy" – "До" рефакторингу 
GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract2/pzpi-23-10-shakhmaiev-denys-pract2

func proc(d map[string]string) error {
    if len(d["password"]) < 8 {
        return fmt.Errorf("password too short")
    }
    if d["email"] == "" {
        return fmt.Errorf("invalid email")
    }
    return nil
}
Рисунок Б.3 – Пояснення методу “Rename method”
func ValidateUserCredentials(userData map[string]string) error {
    if len(userData["password"]) < 8 {
        return fmt.Errorf("password too short")
    }
    if userData["email"] == "" {
        return fmt.Errorf("invalid email")
    }
    return nil
}
Рисунок Б.4 – Пояснення методу “Rename method”
type ReportGenerator struct{}
func (r *ReportGenerator) CreateReport() {
	connectionString := r.getDBConnection()
	fmt.Println("Connecting with:", connectionString)
}
func (r *ReportGenerator) getDBConnection() string {
	return "user:pass@tcp(127.0.0.1)/db"
}
Рисунок Б.5 – Пояснення методу “Hide method”
func (r *ReportGenerator) GetDBConnection() string {
	return "user:pass@tcp(127.0.0.1)/db"
}
Рисунок Б.6 – Пояснення методу “Hide method”
type TextReport struct {}
func (t *TextReport) Generate() {
	fmt.Println("1. Getting text data...")
	fmt.Println("2. Formatting data as Text")
	fmt.Println("3. Saving to .txt file")
}
type CsvReport struct {}
func (c *CsvReport) Generate() {
	fmt.Println("1. Getting CSV data...")
	fmt.Println("2. Formatting data as CSV")
	fmt.Println("3. Saving to .csv file")
}
Рисунок Б.7 – Пояснення методу “ Form Template Method”
type reportImplementation interface {
	getData()
	formatData()
	saveFile()
}
func GenerateReport(impl reportImplementation) {
	impl.getData()
	impl.formatData()
	impl.saveFile()
}
Рисунок Б.8 – Пояснення методу “ Form Template Method”

type textReport struct{}

func (t *textReport) getData()    { fmt.Println("1. Getting text data...") }
func (t *textReport) formatData() { fmt.Println("2. Formatting data as Text") }
func (t *textReport) saveFile()   { fmt.Println("3. Saving to .txt file") }
type csvReport struct{}
func (c *csvReport) getData()    { fmt.Println("1. Getting CSV data...") }
func (c *csvReport) formatData() { fmt.Println("2. Formatting data as CSV") }
func (c *csvReport) saveFile()   { fmt.Println("3. Saving to .csv file") }
Рисунок Б.9 – Пояснення методу “Form Template Method”

