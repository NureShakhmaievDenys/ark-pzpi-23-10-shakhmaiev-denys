МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
Кафедра «Програмна інженерія»






ЗВІТ
з 1 практичної роботи
з дисципліни «Аналіз та рефакторинг коду»








Виконав:                                                           	     Перевірив:
ст. гр. ПЗПІ-23-10                                                        старший викладач Кафедри ПІ
Шахмаєв Д.О                                                               Сокорчук І.П.




Харків 2025


1 ІСТОРІЯ ЗМІН
№ДатаВерсія звітуОпис змін та виправлень110.10.250.1Створено розділ “Опис виконаної
роботи”213.10.250.1Створено додаток а, додаток б.318.10.250.1Створено розділи “Історія змін”,
“Завдання”, “Висновки”420.10.250.1Створено додаток в.















2 ЗАВДАННЯ
     Формулювання завдання згідно з методичними вказівками до практичних занять. Завданням моєї роботи є ознайомлення та аналіз основних принципів написання якісного, високопродуктивного та підтримуваного коду на мові програмування Go (Golang), згідно з філософією "The Go Way". Я прагну показати, наскільки важливе застосування вбудованих інструментів та унікальних можливостей Go, таких як:
• Автоматичне форматування та статичний аналіз коду (go fmt, go vet).
• Ефективна конкурентність через Goroutines та Channels.
• Правила іменування, що визначають видимість (експорт) елементів.
• Використання пакетної структури для організації проєктів.
Це допоможе розробникам:
• Створювати швидкі та ефективні серверні, хмарні та DevOps-застосунки.
• Уникати синтаксичного шуму та забезпечувати максимальну читабельність.
• Створювати надійний код, придатний для командної розробки та масштабування.
Мета полягає у тому, щоб навчитися застосовувати ці принципи для створення лаконічного та професійного програмного коду, що є необхідною складовою підготовки фахівців з інженерії програмного забезпечення.





3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Вступ
Тема моєї доповіді – основні рекомендації щодо написання коду мовою Go (Golang). Чому саме ця тема є важливою? Go, розроблена в Google, вже багато років залишається однією з ключових мов у світі для хмарних сервісів, DevOps та серверної розробки . Її універсальність робить її незамінною у різних сферах: від високоефективних мікросервісів, де вона забезпечує чудову продуктивність, до інструментів командного рядка (наприклад, Docker та Kubernetes написані на Go).
Але сама по собі мова – це лише інструмент. Важливіше, як саме ми його використовуємо. Адже один і той самий функціонал можна реалізувати десятками різних способів, але лише частина з них буде справді якісною, читабельною й зручною для подальшої підтримки. Код – це, по суті, текст, який ми пишемо для комп’ютера, але читають його насамперед люди: інші програмісти, члени команди, або навіть ми самі через кілька місяців. Якщо цей текст незрозумілий, хаотичний і не має структури, то він перетворюється на проблему. Тому тема «чистого коду» настільки актуальна. У своїй доповіді я хочу показати основні принципи, які допоможуть зробити Go-код зрозумілим, логічним і професійним, дотримуючись філософії "The Go Way".
3.2 Читабельність коду та назви змінних
Перше й головне правило гарного програмування – код повинен бути читабельним. У Go іменування не просто визначає читабельність, але й контролює видимість коду (інкапсуляцію).
• PascalCase (Велика літера): Якщо ім'я (змінної, типу, функції) починається з великої літери, воно експортується з пакета і стає публічним.
• camelCase (Мала літера): Якщо ім'я починається з малої літери, воно є приватним і доступне лише всередині свого пакета.
Уявіть, що у вас є змінна з назвою x. Чи зрозуміє людина, що в ній зберігається? А тепер уявіть, що замість «x» ви написали userAge (приватна) або MaxUsers (публічна). У такому випадку навіть без коментарів зрозуміло, що це за дані. Імена в Go – це міні-документація. Особливо це важливо в командній розробці, де над одним проєктом працюють кілька людей.
3.3 Оголошення змінних: var, const та :=
У Go є кілька способів оголосити змінну, кожен з яких має своє призначення, подібно до var, let та const у JavaScript.
• const: Використовується для констант, які не повинні змінюватися. Наприклад, const Pi = 3.14 або const MaxConnections = 100.
• var: Використовується для оголошення змінної, коли її початкове значення невідоме (вона ініціалізується "нульовим" значенням) або коли потрібно явно вказати тип. Наприклад, var userCount int.
• := (Коротке оголошення): Це найбільш ідіоматичний та поширений спосіб оголошення та ініціалізації змінної всередині функцій. Компілятор автоматично виводить тип. Наприклад, userCount := 10.
Сучасна практика Go рекомендує використовувати const для незмінних значень та := для більшості змінних усередині функцій, що робить код лаконічним і безпечним.
3.4 Форматування та відступи (go fmt)
Форматування – це «зовнішній вигляд» вашого коду. Можливо, ви бачили приклади програм, де всі рядки написані підряд, без відступів, пробілів і з хаотичним розташуванням дужок. Такий код виглядає як «суп із літер» і дуже важко зрозуміти, що в ньому відбувається. Уявіть собі роман чи підручник, де немає абзаців і розділів – він був би практично непридатний для читання. Те саме і з програмами.
На відміну від багатьох мов, де стиль форматування є предметом довгих дискусій (наприклад, таби чи пробіли, де ставити дужки), у Go ця проблема вирішена на рівні інструментарію.
Вбудований інструмент go fmt
Мова Go надає вбудований інструмент go fmt (або gofmt), який є не просто рекомендацією, а обов'язковим стандартом для всієї спільноти. Це інструмент для автоматичного форматування коду, який не аналізує логіку, а забезпечує єдиний та акуратний стиль.
• Принцип роботи: go fmt автоматично приводить код до єдиного стилю, розставляє відступи (використовуючи таби), переносить довгі рядки та, що найважливіше, примусово встановлює єдиний стиль розташування дужок. (Див. додаток В.3).
• Уникнення суперечок: Використання go fmt дозволяє команді уникати будь-яких суперечок щодо стилю, оскільки всі учасники дотримуються одного стандарту. Це дозволяє всім учасникам проєкту швидко розуміти чужий код і працювати більш ефективно.
Гарне форматування з відступами, однаковими пробілами та акуратно розставленими дужками допомагає розбивати код на логічні частини. Це робить його не лише зручним для читання, а й для підтримки, що особливо важливо для великих проєктів.
3.5 Сувора статична типізація (Відсутність прихованого приведення типів)
Однією з ключових особливостей Go, яка забезпечує надійність коду, є його сувора статична типізація. У Go не існує поняття "нестрогого" порівняння чи автоматичного приведення типів у виразах. Мова не виконує автоматичного приведення типів під час компіляції чи виконання. Якщо розробник намагається порівняти значення двох різних, несумісних типів (наприклад, int та string), це призведе не до несподіваного логічного результату під час виконання, а до помилки компіляції. Саме тому у професійній практиці Go розробники завжди впевнені у типах даних, з якими працюють. Компілятор вимагає, щоб порівняння відбувалося лише між сумісними типами. Такий підхід унеможливлює цілий клас "підводних каменів", пов'язаних з неявною поведінкою типів, і робить код набагато надійнішим та передбачуваним.
3.6 Принцип DRY (Don’t Repeat Yourself)
Одна з основних проблем у програмуванні – повторення однакових фрагментів коду в різних місцях програми. Це називають дублюванням коду, і воно серйозно ускладнює підтримку проєкту .
Кожна копія коду – це потенційне джерело помилок. Якщо логіка змінюється, програмісту потрібно знайти та відредагувати її у всіх місцях, де вона повторюється, що дуже легко забути . У результаті програма стає важко підтримуваною і небезпечною.
Щоб уникнути цього, рекомендується виділяти повторювані фрагменти в окремі функції. У Go, завдяки системі пакетів, ці функції можна зробити приватними (доступними лише всередині пакета, з малої літери) або публічними (доступними для всього проєкту, з великої літери).
Такий підхід робить код компактнішим, легшим для читання, і будь-які зміни в логіці потрібно робити лише в одному місці. Крім того, це сприяє повторному використанню коду і спрощує тестування. 
3.7 Використання сучасних можливостей (Generics)
Сучасний Go (Golang) активно розвивається, щоб надавати розробникам більш потужні інструменти для написання чистого та ефективного коду. Довгий час однією з найбільших проблем мови була відсутність узагальненого програмування, що змушувало розробників вдаватися до дублювання коду (порушуючи DRY) для різних типів даних.
Починаючи з версії 1.18 (2022 рік), у мові з'явилася найочікуваніша сучасна можливість – Generics (Узагальнені або Параметризовані типи).
Це нововведення дозволяє писати коротші та зрозуміліші вирази, створюючи функції та структури даних, які можуть працювати з будь-яким типом, зберігаючи при цьому повну безпеку типів під час компіляції.
Наприклад, раніше для написання функції, що друкує зріз (slice), потрібно було створювати окрему функцію для []int, окрему для []string тощо. Завдяки Generics, це можна зробити однією універсальною функцією.
Використання сучасних можливостей, таких як Generics, не лише скорочує обсяг коду та зменшує кількість помилок (оскільки логіка не дублюється), але й робить код більш універсальним та легким для повторного використання у команді.
3.8 Умовні оператори та короткі записи (Тернарний оператор)
Коли ми працюємо з умовами, часто виникає потреба написати компактний код. У багатьох мовах для цього використовують тернарний оператор (наприклад, condition ? true_val : false_val) .
Однак у Go (Golang) навмисно відсутній тернарний оператор.
Це свідоме дизайнерське рішення творців мови. Філософія Go ("The Go Way") надає перевагу читабельності та ясності коду над максимальною стислістю. Хоча тернарний оператор може бути зручним для простих умов, він швидко стає нечитабельним, якщо умови складні або вкладені одна в одну.
"Короткий запис" в Go: if з ініціалізатором
Замість тернарного оператора Go пропонує інший, дуже потужний "короткий запис": if стейтмент з ініціалізатором.
Цей синтаксис дозволяє оголосити змінну безпосередньо перед умовою. Головна перевага полягає в тому, що область видимості (scope) цієї змінної обмежується лише блоками if та else.
Це робить код чистішим, оскільки змінна не "забруднює" зовнішню область видимості функції.
Хоча це може здатися трохи більш багатослівним, ніж тернарний оператор, такий підхід значно підвищує читабельність та надійність коду, оскільки чітко обмежує область видимості тимчасових змінних, що є критично важливим для підтримки великих проєктів.
3.9 Робота зі структурами даних: struct (Структури)
У Go (Golang) для групування пов'язаних даних, аналогічно до об'єктів у JavaScript, використовується ключове слово struct (структура). Це потужний і дуже поширений інструмент, який дозволяє створювати власні, суворо типізовані типи даних.
Однак, на відміну від JavaScript, у Go немає прямого синтаксису "деструктуризації" (наприклад, const { name, age } = user) . Філософія Go надає перевагу ясності та явності (explicitness) над стислістю.
"Шлях Go": Явний доступ до полів
Ідіоматичний спосіб роботи з даними структури в Go — це явний доступ до її полів через крапкову нотацію.
Наприклад, замість того, щоб "розпаковувати" властивості об'єкта в окремі змінні, у Go ми просто визначаємо struct і звертаємося до її полів безпосередньо.
Переваги явного доступу
Хоча цей підхід може здатися трохи більш багатослівним, ніж деструктуризація, він має суттєві переваги, що відповідають філософії Go:
1. Читабельність та Ясність: Коли ви бачите user.Name, одразу зрозуміло, з якої саме структури (user) береться поле (Name). Це усуває будь-яку неоднозначність.
2. Безпека типів (Type Safety): Найголовніше — компілятор перевіряє кожне звернення. Якщо ви припуститеся помилки (user.Nmae), програма не скомпілюється. Це запобігає помилкам під час виконання (runtime errors), які могли б виникнути при роботі з динамічними об'єктами або мапами.
Таким чином, хоча Go і не має синтаксичного цукру деструктуризації, він вирішує ту ж проблему (робота з даними) через явний та безпечний для типів доступ до полів struct.
3.10 Обработка ошибок (Явный подход error)
Обработка ошибок в Go (Golang) — это важнейшая часть написания качественного и надежного кода. Поскольку Go часто используется для серверных и системных приложений, ошибки могут возникать в любой момент выполнения программы, особенно при взаимодействии с внешними данными, API-запросами, файловой системой или базами данных .
Если не предусмотреть возможность ошибок, программа может неожиданно остановиться, что приведет к непредсказуемому поведению или потере данных.
Отказ от try...catch
В отличие от многих языков, использующих механизм исключений и конструкцию try...catch , Go придерживается совершенно иного подхода — явной обработки ошибок.
В Go ошибки — это обычные значения, которые возвращаются из функций. Функции, которые могут завершиться неудачно, по соглашению возвращают тип error в качестве последнего возвращаемого значения.
• Если функция выполнилась успешно, она возвращает nil (нулевое значение) для ошибки.
• Если произошла ошибка, функция возвращает объект ошибки с деталями.
Идиома if err != nil
Это заставляет разработчика «перехватывать» ошибку не в блоке catch, а непосредственно в момент ее возникновения с помощью проверки if err != nil.
Блок if содержит код, который потенциально может вызвать ошибку, а проверка err != nil определяет действия, которые выполняются в случае возникновения этой ошибки. Например, в этом блоке можно вывести сообщение пользователю, сохранить детали ошибки в лог-файл или вернуть ошибку на более высокий уровень.
Этот подход позволяет не только избежать аварийного завершения работы программы, но и сделать ее более предсказуемой и управляемой. Поток управления остается линейным и очевидным, а обработка ошибок становится неотъемлемой частью логики программы, которую невозможно случайно проигнорировать.
3.11 Коментарі та Документування (go doc)
Коментарі в Go (Golang) — це важливий інструмент для пояснення логіки коду, який дозволяє розробникам швидко зрозуміти, що відбувається у програмі та чому було прийнято те чи інше рішення.
Вони не повинні дублювати очевидні дії коду. Наприклад, не варто писати // Збільшуємо лічильник біля рядка count++, адже це очевидно з самого коду . Натомість коментарі мають пояснювати складні алгоритми, нетипову бізнес-логіку, причини використання певних методів або особливості роботи з даними. Це особливо корисно у великих проєктах та при командній розробці, коли над кодом працює багато людей .
Вбудований інструмент go doc
Go має потужний вбудований стандартний спосіб документування коду, який обробляється інструментом go doc. Цей підхід дозволяє автоматично генерувати документацію для пакетів, функцій, типів та змінних.
Інструмент go doc не використовує складних спеціальних тегів. Замість цього він дотримується простих синтаксичних правил:
1. Коментар має бути розміщений безпосередньо перед експортованим (публічним) елементом.
2. Коментар повинен починатися з імені елемента, який він документує.
Переваги використання go doc
Використання go doc має кілька суттєвих переваг :
1. Інтеграція з IDE: Сучасні редактори коду (наприклад, Visual Studio Code) автоматично зчитують ці коментарі та показують підказки щодо функцій та їх параметрів, що значно спрощує роботу з кодом .
2. Автоматична генерація документації: За допомогою інструменту go doc (або godoc) можна миттєво згенерувати повноцінну документацію для проєкту у вигляді HTML, що полегшує передачу знань у команді та підтримку коду в довгостроковій перспективі .
3. Прозорість: Використання go doc робить тестування більш прозорим і допомагає новим розробникам швидше орієнтуватися в проєкті.
3.12 Уникнення "магічних чисел" (Константи)
"Магічні числа" — це числові значення (літерали), які з'являються у коді без будь-якого пояснення свого сенсу або призначення . Вони називаються «магічними», тому що інший розробник (або навіть автор коду через деякий час), який читає код, не завжди може зрозуміти, чому саме використано це число і що воно означає .
Використання магічних чисел робить код менш зрозумілим, підвищує ризик помилок і значно ускладнює підтримку програмного забезпечення. Наприклад, якщо в програмі зустрічається рядок if userStatus == 2, не зовсім ясно, що означає 2 — це може бути "активний", "заблокований", "очікує підтвердження" або щось інше.
Використання const
Щоб зробити код більш зрозумілим і легким для підтримки, рекомендується замінювати магічні числа на іменовані константи. У Go для цього використовується ключове слово const.
Це дозволяє пояснити значення числа прямо у коді і, що дуже важливо, легко змінювати його у майбутньому, якщо параметри програми зміняться. У другому прикладі стає абсолютно зрозуміло, що 0.05 – це ставка комісії, а 100.0 – її максимальний поріг . Такий підхід підвищує читабельність коду , робить його більш логічним і зменшує ймовірність помилок при внесенні змін. Якщо завтра потрібно змінити розмір комісії, достатньо змінити значення DefaultCommissionRate в одному місці.
3.13 Асинхронність та Конкурентність у Go (Горутини та Канали)
Мова Go була розроблена з нуля для ефективної конкурентності (одночасного виконання багатьох завдань). Це одна з її ключових переваг. У більшості випадків програми, особливо серверні, повинні обробляти тисячі завдань одночасно, наприклад, мережеві запити, читання файлів або обробку великих обсягів даних .
Якщо виконувати такі операції синхронно (послідовно), весь код «зависне», тобто програма перестане реагувати, доки не завершиться довга задача . Це може призвести до повного блокування сервера або зависання інтерфейсу користувача, що особливо критично для застосунків, де швидкість відгуку є ключовою.
Щоб уникнути блокування та дозволити програмі продовжувати роботу під час очікування довгих операцій, у Go використовують вбудовані механізми конкурентності . Основними інструментами для цього є горутини (Goroutines) та канали (Channels) .
1. Горутини (Goroutines)
Горутина — це функція, яка здатна виконуватися одночасно (конкурентно) з іншими функціями. Це "легковагий потік", яким керує середовище виконання Go, а не операційна система.
• Переваги: Вони надзвичайно ефективні, запускаються дуже швидко і споживають мінімум пам'яті (лише кілька кілобайт). Їх можна створювати сотнями тисяч без великого навантаження на систему.
• Запуск: Горутина запускається дуже просто — за допомогою ключового слова go перед викликом функції. Це дозволяє запустити тривале завдання у фоновому режимі, не зупиняючи основний потік виконання.
2. Канали (Channels)
Просто запустити тисячі горутин недостатньо. Потрібен безпечний спосіб для них обмінюватися інформацією та синхронізувати свою роботу. Для цього в Go існують канали (chan).
• Принцип: Канал — це "труба" з типізованими даними, через яку горутини можуть безпечно надсилати та отримувати дані. Це дозволяє уникнути помилок, пов'язаних зі спільним доступом до пам'яті (race conditions).
• Філософія Go: "Не спілкуйтеся, розділяючи пам'ять; натомість розділяйте пам'ять, спілкуючись".
• Синхронізація: Канали забезпечують синхронізацію за замовчуванням. Коли горутина надсилає дані в канал (ch <- data), вона блокується, доки інша горутина не буде готова отримати ці дані (data := <- ch). Це робить паралельний код безпечним і передбачуваним.
3.14 Модулі та структура коду (Пакети)
Модулі та Пакети в Go — це один із ключових механізмів для організації коду та розподілу його на логічні частини. У великих проєктах код часто стає громіздким і важким для розуміння, особливо якщо всі функції та структури знаходяться в одному файлі або в одному великому пакеті main .
Використання пакетів дозволяє розбивати програму на окремі файли та директорії, кожна з яких відповідає за свою частину логіки (наприклад, пакет database для роботи з базою, http для веб-сервера). Це значно полегшує роботу над проєктом, робить його структуру більш зрозумілою і дозволяє ефективно масштабувати програму.
Головна перевага пакетів полягає в повторному використанні коду. Один пакет можна підключати в різних частинах програми, що дозволяє не дублювати однакову логіку та зменшує ризик помилок.
Крім того, пакети забезпечують інкапсуляцію та підвищують безпеку коду. Дані та функції, які не потрібно використовувати поза пакетом, робляться приватними (починаються з малої літери), тоді як експортовані (з великої літери) елементи стають публічним API пакета .
Управління Модулями (go mod)
Для роботи з пакетами та керування залежностями (зовнішніми бібліотеками) у Go використовується система Модулів.
1. Ініціалізація: Проєкт починається з команди go mod init mymodule, яка створює файл go.mod для відстеження залежностей .
2. Підключення: За допомогою import ми підключаємо потрібні пакети (як стандартні, так і зовнішні).
3. Завантаження: Команда go get використовується для завантаження зовнішніх пакетів, наприклад go get github.com/fatih/color .
Такий підхід робить код більш структурованим і легким для розуміння, а також сприяє кращому тестуванню, оскільки окремий пакет можна протестувати ізольовано .
3.15 map та slice (Мапи та Зрізи)
У Go є сучасні та ефективні вбудовані структури даних – map (мапа) та slice (зріз), які значно спрощують роботу з колекціями та дозволяють ефективніше організовувати дані порівняно зі звичайними масивами.
slice (Зріз)
Зріз (Slice) — це гнучкий та потужний інтерфейс для роботи з послідовностями даних (на базі масиву). Це найпоширеніший тип колекції в Go.
• Принцип: Зріз не володіє даними безпосередньо, а є "поглядом" на базовий масив. Це робить його легковагим, але водночас динамічним.
• Динамічність: На відміну від масивів, зрізи можуть динамічно зростати. Використання вбудованої функції append дозволяє легко додавати нові елементи.
• Операції: Зрізи мають функцію len() для отримання довжини, cap() для отримання ємності (capacity) базового масиву, а також дозволяють легко створювати "під-зрізи" (наприклад, mySlice[1:3]).
map (Мапа)
Мапа (Map) — це вбудована колекція пар "ключ-значення", яка дає більше можливостей порівняно з простим масивом чи зрізом.
• Типізація ключів: У map ключами можуть бути не тільки рядки, а й практично будь-які типи даних, що підтримують порівняння (числа, структури, булеві значення тощо). Це робить map надзвичайно гнучким для зберігання складних даних.
• Невпорядкованість: Важливою особливістю map є те, що вона не гарантує збереження порядку додавання елементів. При ітерації по map порядок буде випадковим.
• Операції: map має функцію make() для створення, delete() для видалення елемента за ключем, а також спеціальний синтаксис для перевірки наявності ключа ("comma ok idiom").
3.16 Інструменти для статичного аналізу (go vet)
У сучасній розробці на Go особливу увагу приділяють якості коду. Це важливо не лише для того, щоб код працював правильно, а й для того, щоб його було легко читати, підтримувати та масштабувати, особливо коли над проєктом працює команда розробників .
Якщо інструмент go fmt (описаний у 3.4) відповідає за зовнішній вигляд та форматування, то за логічну коректність та пошук потенційних помилок відповідає інший вбудований інструмент — go vet .
go vet — це статичний аналізатор коду для Go, який дозволяє перевіряти код на наявність підозрілих конструкцій, синтаксичних помилок та потенційних багів ще до запуску програми.
Використання go vet допомагає підтримувати чистоту коду, уникати логічних помилок і забезпечує більш структуровану роботу над проєктом. Основні можливості цього інструменту включають:
• Виявлення невикористовуваних змінних або імпортів.
• Пошук недосяжного коду (dead code).
• Помилки у форматуванні рядків Printf (наприклад, передача int замість string).
• Потенційно небезпечні конструкції, такі як копіювання mutex (що може призвести до "дедлоків").
• Інші логічні помилки, які компілятор вважає синтаксично правильними.
go vet є частиною стандартного набору інструментів Go і, як правило, інтегрується з популярними редакторами коду (наприклад, Visual Studio Code), що дозволяє відразу підсвічувати помилки та попередження під час написання коду.
3.17 Unit-тести та TDD у Go (go test)
Unit-тести та підхід TDD (Test-Driven Development) є найважливішими складовими якісної розробки програмного забезпечення на Go. Вони дозволяють перевіряти роботу окремих компонентів коду ще на ранніх етапах розробки та забезпечують високу надійність програми .
Юніт-тестування (Unit testing) передбачає створення тестів для невеликих одиниць коду — функцій, методів або модулів — з метою впевненості, що кожен елемент працює відповідно до очікувань. Такий підхід дозволяє швидко виявляти помилки, спрощує внесення змін у код (рефакторинг) і знижує ризик того, що нові зміни випадково порушать роботу вже існуючого функціоналу .
Test-Driven Development (TDD) — це методика розробки, яка передбачає написання тестів перед створенням основного коду. Основна ідея TDD полягає в тому, щоб спочатку визначити очікувану поведінку функції у вигляді тесту (який спершу не проходить), а потім написати мінімальний код, необхідний для успішного проходження цього тесту. Після цього код оптимізується (рефакторинг), а тест повторно запускається, щоб переконатися у правильності змін.
Вбудований інструмент go test
Go має потужний та вбудований фреймворк для тестування, який доступний "з коробки" через команду go test. Це усуває необхідність у виборі та налаштуванні сторонніх бібліотек для тестування.
go test пропонує "все в одному":
1. Запуск тестів: Автоматично знаходить файли з суфіксом _test.go та запускає функції, що починаються з Test.
2. Бібліотека перевірок (Assertion): Надає об'єкт t (*testing.T), який містить методи для повідомлення про помилки (напр., t.Errorf() або t.Fatalf()).
3. Бенчмаркінг: Дозволяє вимірювати продуктивність коду (функції, що починаються з Benchmark).
Завдяки швидкості компіляції та простоті go test, підхід TDD стає дуже природним: розробник може дисципліновано будувати проєкт, уникати зайвих багів і створювати більш надійний та прогнозований код .














4. ВИСНОВКИ
     У підсумку, дотримання правил чистого та сучасного програмування в Go (Golang) — це не просто набір рекомендацій, а фундамент для створення якісного, надійного та високопродуктивного коду. Читабельність коду та зрозумілі імена, де капіталізація (PascalCase vs camelCase) контролює видимість, допомагають миттєво орієнтуватися в логіці програми та знижують ризик помилок. Використання := та const замість var робить код лаконічним і безпечним, чітко розділяючи змінні та константи. Вбудована автоматизація, зокрема go fmt, забезпечує єдиний стиль у всій команді, усуваючи суперечки про форматування, тоді як сувора статична типізація запобігає цілому класу помилок під час виконання, пов'язаних з приведенням типів. Принцип DRY та використання Generics дозволяють писати компактний та ефективний код, який легко підтримувати і тестувати. Ключові особливості Go, такі як явна обробка помилок (if err != nil), забезпечують надійність програм, не дозволяючи ігнорувати збої. Вбудована асинхронність із застосуванням горутин та каналів гарантує плавну та безпечну паралельну роботу, не блокуючи основний потік. Модулі та правильна організація структури коду сприяють масштабованості. Вбудовані інструменти для статичного аналізу, такі як go vet, допомагають підтримувати єдиний стандарт коду та знаходити логічні помилки. Нарешті, впровадження unit-тестів (go test) та підхід TDD дозволяють створювати стабільний та надійний функціонал, впевнено виявляти й виправляти помилки на ранніх етапах. Разом ці практики формують комплексний підхід "The Go Way", що забезпечує не лише працездатність програми, а і її довгострокову підтримуваність, масштабованість та високу якість. Впроваджуючи ці принципи, розробник не тільки підвищує ефективність власної роботи, а й створює продукт, який буде зрозумілим, надійним і легким у супроводі для всієї команди.


5. СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ
1. Офіційна Документація Go. URL: https://golang.org/doc/ 
2. Docker (Moby Project) GitHub. URL: https://github.com/moby/moby 
3. Kubernetes GitHub. URL: https://github.com/kubernetes/kubernetes 
4. Prometheus GitHub. URL: https://github.com/prometheus/prometheus 
5. Terraform GitHub. URL: https://github.com/hashicorp/terraform 
















ДОДАТОК А
https://youtu.be/TOi16YIZpNo
0:00 - Вступ 
0:16 - Вступ та філософія 
1:14 - Cтруктура коду: Організація пакетів та Файлів
1:56 - Cтруктура коду: Принципи логічного поділу
2:44 - Форматування Коду
3:35 - Форматування Коду: Стандарти для дужок
4:02 - Іменування: Конвенції та принцип видимості
4:20 - Іменування: принцип вибору імен
4:46 - Коментарі: Коли та де використовувати
5:04 - Документування коду
5:20 - Конвенції стилю кодування та Автоматизація
5:49 - Кодування на основі тестування (TDD)
6:07 - Паралелізм: Goroutines та Channels
6:49 - Загальні приклади оформлення коду та їх аналіз
7:03 - Загальні приклади оформлення коду та їх аналіз part 2
7:07 - Висновок
7:33 - Список Джерел




ДОДАТОК Б
Слайди презентації

Рисунок Б.1 – Титульний лист


Рисунок Б.2 – Вступ


Рисунок Б.3 – Організація Пакетів та Файлів

Рисунок Б.4 – Принципи логічного поділу

Рисунок Б.5 – Форматування коду


Рисунок Б.6 – Форматування коду


Рисунок Б.7 – Іменування Конвенції

Рисунок Б.8 – Іменування Конвенції

Рисунок Б.9 – Коментарії


Рисунок Б.10 – Документування коду

Рисунок Б.11 – Конвенції стилю кодування та Автоматизація

Рисунок Б.12 – Кодування на основі тестування (TDD)




Рисунок Б.13 – Паралелізм: Goroutines та Channels


Рисунок Б.14 – Загальні приклади оформлення коду та їх аналіз

Рисунок Б.15 – Загальні приклади оформлення коду та їх аналіз

Рисунок Б.16 – Висновки

Рисунок Б.17 – Список Джерел



















ДОДАТОК В
Програмний код
В.1 Приклад структури пакета (main) та імпортів GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1
1  package main // Виконуваний пакет
 2  
 3  import (
 4      "fmt" // Стандартна бібліотека
 5      "os"
 6  
 7      // Зовнішня бібліотека (модуль)
 8      // "github.com/fatih/color" 
 9  )
10  
11  func main() {
12      fmt.Println("Hello, world!", os.Args[0])
13      // color.Red("Приклад використання зовнішнього пакету")
14  }
Назва блоку коду: Базовий синтаксис та структура пакету Go.

В.2 Приклад форматування go fmt (до і після) GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  // До go fmt (погано)
 2  func badFunc(a int,b int)int{
 3  if a > b {
 4  return a
 5  } else { return b }
 6  }
 7  
 8  // Після go fmt (добре)
 9  func goodFunc(a, b int) int {
10      if a > b {
11          return a
12      } else {
13          return b
14      }
15  }
Назва блоку коду: Демонстрація автоматичного форматування go fmt.

В.3 Приклад іменування (Експорт та видимість) GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  package store
 2  
 3  // MaxItems — публічна константа (експортується)
 4  const MaxItems = 100 
 5  
 6  // userCache — приватна змінна (не експортується)
 7  var userCache map[int]string
 8  
 9  // GetUser — публічна функція
10  func GetUser(id int) string {
11      return "username"
12  }
13  
14  // logAccess — приватна функція
15  func logAccess(id int) {
16      // ...
17  }
Назва блоку коду: Правила іменування та експорту елементів у Go.

В.4 Приклад вибору імен (Короткі імена) GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  import "net/http"
 2  
 3  // Погано, краще коротше
 4  var loopIndex int 
 5  // Добре
 6  var i int 
 7  
 8  // Погано
 9  var requestHandlerFunction func() 
10  // Добре (коротше, контекст задає пакет)
11  var h http.Handler 
Назва блоку коду: Ідіоматичне використання коротких імен у Go.

В.5 Приклад коментарів для go doc GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1
 1  package httpclient
 2  
 3  // MaxConnections — максимальна кількість одночасних підключень.
 4  const MaxConnections = 10
 5  
 6  // Get виконує HTTP GET-запит за вказаною URL.
 7  // Повертає тіло відповіді або помилку, якщо запит не вдався.
 8  func Get(url string) ([]byte, error) {
 9      // ...
10      return nil, nil
11  }
Назва блоку коду: Правильне оформлення коментарів для go doc.

В.6 Приклад коментарів (Поганий стиль) GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  // Погано:
 2  // Оголошуємо функцію факторіала (дублює код)
 3  func factorial(n int) int {
 4      // Якщо n менше або дорівнює 1, повертаємо 1 (очевидно)
 5      if n <= 1 { 
 6          return 1 
 7      }
 8      // Повертаємо n помножене на факторіал (n - 1)
 9      return n * factorial(n - 1)
10  }
Назва блоку коду: Приклад надлишкових та неочевидних коментарів.

В.7 Приклад використання go vet GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  import "fmt"
 2  
 3  func main() {
 4      // go vet: "a declared but not used"
 5      a := 10 
 6  
 7      // go vet: "mismatched types: got int, expected string"
 8      fmt.Printf("Number: %s", 123) 
 9  }
Назва блоку коду: Код, що демонструє помилки, які знаходить go vet.

В.8 Приклад Unit-тесту (go test) GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  package main
 2  
 3  import "testing"
 4  
 5  // Функція, що тестується
 6  func Add(a, b int) int {
 7      return a + b
 8  }
 9  
10  // Юніт-тест для функції Add
11  func TestAdd(t *testing.T) {
12      result := Add(2, 3)
13      expected := 5
14  
15      // Перевірка (Assertion)
16      if result != expected {
17          t.Errorf("Add(2, 3) = %d; очікувалось %d", result, expected)
18      }
19  }
Назва блоку коду: Структура юніт-тесту в Go.

В.9 Приклад запуску Горутини GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  import (
 2      "fmt"
 3      "time"
 4  )
 5  
 6  func sayHello() {
 7      fmt.Println("Hello from goroutine!")
 8  }
 9  
10  func main() {
11      // Запускаємо функцію в окремій горутині
12      go sayHello() 
13      
14      fmt.Println("Main function finished")
15      time.Sleep(1 * time.Second) // Чекаємо, щоб горутина встигла виконатись
16  }
Назва блоку коду: Запуск паралельної задачі за допомогою go.

В.10 Приклад використання Каналів GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  import "fmt"
 2  
 3  func main() {
 4      // Створюємо канал для рядків
 5      ch := make(chan string)
 6  
 7      go func() {
 8          // Надсилаємо дані в канал
 9          ch <- "Message from goroutine" 
10      }()
11  
12      // Отримуємо (читаємо) дані з каналу
13      msg := <-ch 
14      fmt.Println(msg)
15  }
Назва блоку коду: Обмін даними між горутинами через канал.

В.11 Приклад Generics (Узагальнені типи) GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  import "fmt"
 2  
 3  // Ця функція приймає зріз БУДЬ-ЯКОГО типу
 4  func PrintSlice[T any](s []T) {
 5      for _, v := range s {
 6          fmt.Println(v)
 7      }
 8  }
 9  
10  func main() {
11      ints := []int{1, 2, 3}
12      strings := []string{"a", "b", "c"}
13  
14      PrintSlice(ints)
15      PrintSlice(strings)
16  }
Назва блоку коду: Використання Generics для уникнення дублювання коду.

В.12 Приклад коду до рефакторинґу (Порушення іменування) GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1

 1  // Гіпотетичний поганий приклад Go коду:
 2  // Назва функції порушує конвенцію, аргументи з великої літери
 3  func calculate_TOTAL(Price float64, Quantity int) float64 {
 4      // ... логіка розрахунку
 5      return 0.0
 6  }
Назва блоку коду: Порушення конвенцій іменування Go.

В.13 Приклад коду після рефакторинґу (Відповідно до Go Style) GitHub репозиторій: https://github.com/NureShakhmaievDenys/ark-pzpi-23-10-shakhmaiev-denys/tree/main/Pract1/pzpi-23-10-shakhmaiev-denys-pract1
 1  // Після рефакторингу:
 2  // Назва експортована, аргументи з малої (приватні для функції)
 3  func CalculateTotal(price float64, quantity int) float64 {
 4      // ... логіка розрахунку
 5      return 0.0
 6  }
Назва блоку коду: Виправлене іменування відповідно до правил Go.
2





